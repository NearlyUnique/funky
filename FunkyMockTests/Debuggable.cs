using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using System.Diagnostics;
using System.Reflection;
using FunkyMock;
using FunkyMock.External;
using Xunit;

namespace FunkyMockTests;

[Collection("AllowTesting-IndentedStringBuilder.NewLine")]
public class Debuggable
{
    [Fact]
    public void SimpleGeneratorTest()
    {
        var eol = IndentedStringBuilder.DefaultNewLine;
        try
        {
            // this file is LF (not CRLF) so we need to "normalise" the line ending
            IndentedStringBuilder.DefaultNewLine = "\n";
            Compilation inputCompilation = CreateCompilation(@"
namespace Root.MyCode {
    using System;
    public class AnyType {
        public string Word {get;set;}
    }

    public interface IThing {
        string Text(int number);
        bool Predicate(float f, AnyType anyType);
        DateTime ReadOnly {get;}
        int ReadWrite {get;set;}
        bool WriteOnly {set;}
    }
}
namespace OtherRoot.Testing {
    using Root.MyCode;

    //[Funky(typeof(string))]
    [Funky]
    public partial class AnyMocker : IThing {
        // Will match 'GeneratedSource'
    }
}
public static class App{public static void Main(){}}
");

            // directly create an instance of the generator
            // (Note: in the compiler this is loaded from an assembly, and created via reflection at runtime)
            var generator = new FunkyIncrementalGenerator();

            // Create the driver that will control the generation, passing in our generator
            GeneratorDriver driver = CSharpGeneratorDriver.Create(generator);

            // Run the generation pass
            // (Note: the generator driver itself is immutable, and all calls return an updated version of the driver that you should use for subsequent calls)
            driver = driver.RunGeneratorsAndUpdateCompilation(inputCompilation, out var outputCompilation,
                out var diagnostics);

            // We can now assert things about the resulting compilation:
            Debug.Assert(diagnostics.IsEmpty); // there were no diagnostics created by the generators
            Debug.Assert(outputCompilation.SyntaxTrees.Count() ==
                         3); // we have three syntax trees, the original 'user' provided one, our fixed 'Funky' attribute and the one added by the generator
            // Debug.Assert(outputCompilation.GetDiagnostics().IsEmpty); // verify the compilation with the added source has no diagnostics
            //
            // // Or we can look at the results directly:
            GeneratorDriverRunResult runResult = driver.GetRunResult();
            //
            // // The runResult contains the combined results of all generators passed to the driver
            // Debug.Assert(runResult.GeneratedTrees.Length == 1);
            // Debug.Assert(IsEmpty);
            //
            // // Or you can access the individual results on a by-generator basis
            GeneratorRunResult generatorResult = runResult.Results[0];
            // // Debug.Assert(generatorResult.Generator == generator);
            // Debug.Assert(generatorResult.Diagnostics.IsEmpty);
            Debug.Assert(generatorResult.GeneratedSources.Length == 2);
            var source = generatorResult.GeneratedSources[1].SourceText.ToString();

            Assert.Equal(GeneratedSource, source);
            // Debug.Assert(generatorResult.Exception is null);
        }
        finally
        {
            IndentedStringBuilder.DefaultNewLine = eol;
        }
    }

    private static Compilation CreateCompilation(string source)
        => CSharpCompilation.Create("compilation",
            new[] { CSharpSyntaxTree.ParseText(source) },
            new[] { MetadataReference.CreateFromFile(typeof(Binder).GetTypeInfo().Assembly.Location) },
            new CSharpCompilationOptions(OutputKind.ConsoleApplication));

    private const string GeneratedSource = """
// <auto-generated/>
#nullable enable
namespace OtherRoot.Testing;

// Standard global using
using global::System;
using global::System.Collections.Generic;
using global::System.IO;
using global::System.Linq;
using global::System.Net.Http;
using global::System.Threading;
using global::System.Threading.Tasks;

public partial class AnyMocker : Root.MyCode.IThing
{
    public Func<int, string>? OnText;
    public Func<float, Root.MyCode.AnyType, bool>? OnPredicate;
    public Func<System.DateTime>? OnGetReadOnly;
    public Func<int>? OnGetReadWrite;
    public Action<int>? OnSetReadWrite;
    public Action<bool>? OnSetWriteOnly;

    public CallHistory Calls { get; } = new();

    public class CallHistory
    {
        public List<TextArgs> Text { get; } = new();
        public List<PredicateArgs> Predicate { get; } = new();
        public List<GetReadOnlyArgs> GetReadOnly { get; } = new();
        public List<GetReadWriteArgs> GetReadWrite { get; } = new();
        public List<SetReadWriteArgs> SetReadWrite { get; } = new();
        public List<SetWriteOnlyArgs> SetWriteOnly { get; } = new();

        public record TextArgs(int number);
        public record PredicateArgs(float f, Root.MyCode.AnyType anyType);
        public record GetReadOnlyArgs();
        public record GetReadWriteArgs();
        public record SetReadWriteArgs(int value);
        public record SetWriteOnlyArgs(bool value);
    }

    public string Text(int number) {
        Calls.Text.Add(new CallHistory.TextArgs(number));
        if (OnText is null) { throw new System.NotImplementedException("'OnText' has not been assigned"); }
        return OnText(number);
    }
    public bool Predicate(float f, Root.MyCode.AnyType anyType) {
        Calls.Predicate.Add(new CallHistory.PredicateArgs(f, anyType));
        if (OnPredicate is null) { throw new System.NotImplementedException("'OnPredicate' has not been assigned"); }
        return OnPredicate(f, anyType);
    }
    public System.DateTime ReadOnly {
        get {
            Calls.GetReadOnly.Add(new CallHistory.GetReadOnlyArgs());
            if (OnGetReadOnly is null) { throw new System.NotImplementedException("'OnGetReadOnly' has not been assigned"); }
            return OnGetReadOnly();
        }
    }
    public int ReadWrite {
        get {
            Calls.GetReadWrite.Add(new CallHistory.GetReadWriteArgs());
            if (OnGetReadWrite is null) { throw new System.NotImplementedException("'OnGetReadWrite' has not been assigned"); }
            return OnGetReadWrite();
        }
        set {
            Calls.SetReadWrite.Add(new CallHistory.SetReadWriteArgs(value));
            if (OnSetReadWrite is null) { throw new System.NotImplementedException("'OnSetReadWrite' has not been assigned"); }
            OnSetReadWrite(value);
        }
    }
    public bool WriteOnly {
        set {
            Calls.SetWriteOnly.Add(new CallHistory.SetWriteOnlyArgs(value));
            if (OnSetWriteOnly is null) { throw new System.NotImplementedException("'OnSetWriteOnly' has not been assigned"); }
            OnSetWriteOnly(value);
        }
    }
}

""";
}
