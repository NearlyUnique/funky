using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using System.Diagnostics;
using System.Reflection;
using FunkyMock;
using FunkyMock.Internal;
using Microsoft.CodeAnalysis.Diagnostics;
using Xunit;

namespace FunkyMockTests;

public class Debuggable
{
    [Fact]
    public void SimpleGeneratorTest()
    {
        Compilation inputCompilation = CreateCompilation(@"
namespace Root.MyCode {
    using System;
    public class AnyType {
        public string Word {get;set;}
    }

    public interface IThing {
        string Text(int number);
        bool Predicate(float f, AnyType anyType);
        DateTime ReadOnly {get;}
        int ReadWrite {get;set;}
        bool WriteOnly {set;}
    }
}
namespace OtherRoot.Testing {
    using Root.MyCode;

    [Funky]
    public partial class AnyMocker : IThing {
        // Will match 'GeneratedSource'
    }
}
public static class App{public static void Main(){}}
");

        // directly create an instance of the generator
        // (Note: in the compiler this is loaded from an assembly, and created via reflection at runtime)
        var generator = new FunkyIncrementalGenerator();

        // Create the driver that will control the generation, passing in our generator
        GeneratorDriver driver = CSharpGeneratorDriver.Create(generator);
        //driver.WithUpdatedParseOptions(new CSharpParseOptions());
        driver = driver.WithUpdatedAnalyzerConfigOptions(
            new TestAnalyzerConfigOptionsProvider(("funky.implicit_interfaces", "true")));

        // Run the generation pass
        // (Note: the generator driver itself is immutable, and all calls return an updated version of the driver that you should use for subsequent calls)
        driver = driver.RunGeneratorsAndUpdateCompilation(inputCompilation, out var outputCompilation,
            out var diagnostics);

        // We can now assert things about the resulting compilation:
        Debug.Assert(diagnostics.IsEmpty); // there were no diagnostics created by the generators
        // we have syntax trees
        // 1. the original 'user' provided one
        // 2. our fixed 'Funky' attribute
        // 3. the one added by the generator
        // 4. IFF Logger.IsEnabled then the log file
        Debug.Assert(outputCompilation.SyntaxTrees.Count() == 3 + (Logger.IsEnabled ? 1 : 0));
        // Debug.Assert(outputCompilation.GetDiagnostics().IsEmpty); // verify the compilation with the added source has no diagnostics
        //
        // // Or we can look at the results directly:
        GeneratorDriverRunResult runResult = driver.GetRunResult();
        //
        // // The runResult contains the combined results of all generators passed to the driver
        // Debug.Assert(runResult.GeneratedTrees.Length == 1);
        // Debug.Assert(IsEmpty);
        //
        // // Or you can access the individual results on a by-generator basis
        GeneratorRunResult generatorResult = runResult.Results[0];
        // // Debug.Assert(generatorResult.Generator == generator);
        // Debug.Assert(generatorResult.Diagnostics.IsEmpty);
        Debug.Assert(generatorResult.GeneratedSources.Length == 2 + (Logger.IsEnabled ? 1 : 0));
        var source = generatorResult.GeneratedSources[1].SourceText.ToString();

        Assert.Equal(GeneratedSource, source);
        // Debug.Assert(generatorResult.Exception is null);
    }

    private static Compilation CreateCompilation(string source)
        => CSharpCompilation.Create("compilation",
            new[] { CSharpSyntaxTree.ParseText(source) },
            new[] { MetadataReference.CreateFromFile(typeof(Binder).GetTypeInfo().Assembly.Location) },
            new CSharpCompilationOptions(OutputKind.ConsoleApplication));

    private const string GeneratedSource = """
// <auto-generated/>
#nullable enable
namespace OtherRoot.Testing;

// Standard global using
using global::System;
using global::System.Collections.Generic;
using global::System.IO;
using global::System.Linq;
using global::System.Net.Http;
using global::System.Threading;
using global::System.Threading.Tasks;

public partial class AnyMocker : Root.MyCode.IThing
{
    public Func<int, string>? OnText;
    public Func<float, Root.MyCode.AnyType, bool>? OnPredicate;
    public Func<System.DateTime>? OnGetReadOnly;
    public Func<int>? OnGetReadWrite;
    public Action<int>? OnSetReadWrite;
    public Action<bool>? OnSetWriteOnly;

    public CallHistory Calls { get; } = new();

    public class CallHistory
    {
        public List<TextArgs> Text { get; } = new();
        public List<PredicateArgs> Predicate { get; } = new();
        public List<GetReadOnlyArgs> GetReadOnly { get; } = new();
        public List<GetReadWriteArgs> GetReadWrite { get; } = new();
        public List<SetReadWriteArgs> SetReadWrite { get; } = new();
        public List<SetWriteOnlyArgs> SetWriteOnly { get; } = new();

        public record TextArgs(int number);
        public record PredicateArgs(float f, Root.MyCode.AnyType anyType);
        public record GetReadOnlyArgs();
        public record GetReadWriteArgs();
        public record SetReadWriteArgs(int value);
        public record SetWriteOnlyArgs(bool value);
    }

    string Root.MyCode.IThing.Text(int number) {
        Calls.Text.Add(new CallHistory.TextArgs(number));
        if (OnText is null) { throw new System.NotImplementedException("'OnText' has not been assigned"); }
        return OnText(number);
    }
    bool Root.MyCode.IThing.Predicate(float f, Root.MyCode.AnyType anyType) {
        Calls.Predicate.Add(new CallHistory.PredicateArgs(f, anyType));
        if (OnPredicate is null) { throw new System.NotImplementedException("'OnPredicate' has not been assigned"); }
        return OnPredicate(f, anyType);
    }
    System.DateTime Root.MyCode.IThing.ReadOnly {
        get {
            Calls.GetReadOnly.Add(new CallHistory.GetReadOnlyArgs());
            if (OnGetReadOnly is null) { throw new System.NotImplementedException("'OnGetReadOnly' has not been assigned"); }
            return OnGetReadOnly();
        }
    }
    int Root.MyCode.IThing.ReadWrite {
        get {
            Calls.GetReadWrite.Add(new CallHistory.GetReadWriteArgs());
            if (OnGetReadWrite is null) { throw new System.NotImplementedException("'OnGetReadWrite' has not been assigned"); }
            return OnGetReadWrite();
        }
        set {
            Calls.SetReadWrite.Add(new CallHistory.SetReadWriteArgs(value));
            if (OnSetReadWrite is null) { throw new System.NotImplementedException("'OnSetReadWrite' has not been assigned"); }
            OnSetReadWrite(value);
        }
    }
    bool Root.MyCode.IThing.WriteOnly {
        set {
            Calls.SetWriteOnly.Add(new CallHistory.SetWriteOnlyArgs(value));
            if (OnSetWriteOnly is null) { throw new System.NotImplementedException("'OnSetWriteOnly' has not been assigned"); }
            OnSetWriteOnly(value);
        }
    }
}

""";
}

public class TestAnalyzerConfigOptionsProvider : AnalyzerConfigOptionsProvider
{
    public Dictionary<string, string> Map { get; } = new();

    public TestAnalyzerConfigOptionsProvider(params (string key, string value)[] pairs)
    {
        pairs.ToList().ForEach(x => Map.Add(x.key, x.value));
    }

    public override AnalyzerConfigOptions GetOptions(SyntaxTree tree) => throw new NotImplementedException();

    public override AnalyzerConfigOptions GetOptions(AdditionalText textFile) => throw new NotImplementedException();

    public override AnalyzerConfigOptions GlobalOptions => new TestAnalyzerConfigOptions(Map);
}

internal class TestAnalyzerConfigOptions : AnalyzerConfigOptions
{
    private readonly Dictionary<string, string> _map;

    public TestAnalyzerConfigOptions(Dictionary<string, string> map) => _map = map;

    public override bool TryGetValue(string key, out string value) => _map.TryGetValue(key, out value!);

    public override IEnumerable<string> Keys => _map.Keys;
}
