using FunkyMock.External;
using Microsoft.CodeAnalysis;

namespace FunkyMock;

/// <summary>
/// Methods to write C# source code
/// </summary>
public static class SourceCode
{
    /// <summary>
    /// I'm not happy about adding this. But currently I cannot work out how to fully qualify all types found on the interface
    /// </summary>
    public const string GlobalUsing = """
// Standard global using
using global::System;
using global::System.Collections.Generic;
using global::System.IO;
using global::System.Linq;
using global::System.Net.Http;
using global::System.Threading;
using global::System.Threading.Tasks;
""";

    /// <summary>
    /// public {returnType} {name}(arg list)
    /// </summary>
    /// <returns></returns>
    public static string Signature(SimpleSyntax.Method m)
    {
        if (m.Kind == MethodKind.Ordinary)
        {
            return $"public {m.ReturnType} {m.Name}({string.Join(", ", m.Args)})";
        }
        return $"public {m.ReturnType} {m.Name}";
    }

    /// <summary>
    /// public [Func|Action] &lt;{type list}&gt;;
    /// </summary>
    /// <returns></returns>
    public static string FuncPointer(MethodKind kind, SimpleSyntax.Method m)
    {
        var funcType = "Action";
        var args = new List<string>();

        args.AddRange(m.Args.Select(x => x.Type));
        if (m.ReturnType != "void" && kind != MethodKind.WriteProperty)
        {
            funcType = "Func";
            args.Add(m.ReturnType);
        }

        if (kind == MethodKind.WriteProperty)
        {
            args.Add(m.ReturnType);
        }

        string typeParams = "";
        if (args.Any())
        {
            typeParams = "<"+string.Join(", ", args)+">";
        }
        var name = (kind & m.Kind) switch {
            MethodKind.Ordinary => m.Name,
            MethodKind.ReadProperty => "Get"+m.Name,
            MethodKind.WriteProperty => "Set"+m.Name,
            _ => throw new InvalidOperationException("Ordinary, ReadProperty or Write Property only")
        };

        return $"public {funcType}{typeParams}? On{name};";
    }

    /// <summary>
    /// (return) On{name}(args);
    /// </summary>
    /// <returns></returns>
    public static string InvokeFuncPointer(MethodKind kind, SimpleSyntax.Method m)
    {
        return (m.Kind & kind) switch {
            MethodKind.Ordinary => $"{(m.ReturnType == "void"?"":"return ")}On{m.Name}({string.Join(", ", m.Args.Select(x => x.Name))});",
            MethodKind.ReadProperty => $"return OnGet{m.Name}();",
            MethodKind.WriteProperty =>$"OnSet{m.Name}(value);",
            _=> throw new ArgumentException($"kind ({kind}) does not match {m.Kind}", nameof(kind))
        };
    }

    /// <summary>
    /// if ( On{MethodName} is null ) throw Exception();
    /// </summary>
    /// <param name="kind">required kind</param>
    /// <param name="m"></param>
    /// <returns></returns>
    public static string ThrowIfNull(MethodKind kind, SimpleSyntax.Method m)
    {
        var name = (kind&m.Kind) switch {
            MethodKind.Ordinary => m.Name,
            MethodKind.ReadProperty => "Get"+m.Name,
            MethodKind.WriteProperty => "Set"+m.Name,
            _ => throw new ArgumentException($"Cannot use ({kind})Ordinary, ReadProperty or Write Property only", nameof(kind))
        };

        return
            $"if (On{name} is null) {{ throw new System.NotImplementedException(\"'On{name}' has not been assigned\"); }}";
    }

    public static string Execute(FunkyContext source)
    {
        var targetInterface = source.TargetInterface;

        var srcBuilder = new IndentedStringBuilder();

        srcBuilder
            .AppendLine("// <auto-generated/>")
            .AppendLine("#nullable enable")
            .AppendLine($"namespace {SimpleSyntax.Namespace(source.MockClass)};")
            .AppendLine()
            .AppendLine(GlobalUsing)
            .AppendLine()
            .AppendLine($"{SimpleSyntax.Accessibility(source.MockClass)} partial class {source.MockClassName} : {SimpleSyntax.Namespace(source.TargetInterface)}.{source.TargetInterfaceName}")
            .AppendLine("{")
            .IncrementIndent();

        var members = SimpleSyntax.Members(targetInterface).ToList();

        AddFunctionPointers(srcBuilder, members);

        CallHistoryGenerator.Generate(srcBuilder, members);

        srcBuilder.AppendLine();
        ImplementInterface(srcBuilder, members);

        srcBuilder
            .DecrementIndent()
            .AppendLine("}");

        return srcBuilder.ToString();
    }

    private static void ImplementInterface(IndentedStringBuilder srcBuilder, IEnumerable<SimpleSyntax.Method> members)
    {
        foreach (var member in members)
        {
            srcBuilder.Append(Signature(member))
                .AppendLine(" {")
                .IncrementIndent();

            if (member.Kind == MethodKind.Ordinary)
            {
                InnerMethodBody(srcBuilder, member);
            }
            else
            {
                InnerPropertyBody(srcBuilder, member);
            }

            srcBuilder
                .DecrementIndent()
                .AppendLine("}");
        }
    }

    private static void AddFunctionPointers(IndentedStringBuilder srcBuilder, IEnumerable<SimpleSyntax.Method> members)
    {
        void AppendIf(MethodKind kind, SimpleSyntax.Method member)
        {
            if ((member.Kind & kind) != 0)
            {
                srcBuilder.AppendLine(FuncPointer(kind, member));
            }
        }

        foreach (var member in members)
        {
            AppendIf(MethodKind.Ordinary, member);
            AppendIf(MethodKind.ReadProperty, member);
            AppendIf(MethodKind.WriteProperty, member);
        }

        srcBuilder.AppendLine();
    }

    private static void InnerPropertyBody(IndentedStringBuilder srcBuilder, SimpleSyntax.Method member)
    {
        if ((member.Kind & MethodKind.ReadProperty) != 0)
        {
            srcBuilder
                .AppendLine("get {")
                .IncrementIndent()
                .AppendLine(CallHistoryGenerator.GenerateAddCall(MethodKind.ReadProperty, member))
                .AppendLine(ThrowIfNull(MethodKind.ReadProperty, member))
                .AppendLine(InvokeFuncPointer(MethodKind.ReadProperty, member))
                .DecrementIndent()
                .AppendLine("}");
        }
        if ((member.Kind & MethodKind.WriteProperty) != 0)
        {
            srcBuilder
                .AppendLine("set {")
                .IncrementIndent()
                .AppendLine(CallHistoryGenerator.GenerateAddCall(MethodKind.WriteProperty, member))
                .AppendLine(ThrowIfNull(MethodKind.WriteProperty, member))
                .AppendLine(InvokeFuncPointer(MethodKind.WriteProperty, member))
                .DecrementIndent()
                .AppendLine("}");
        }
    }

    private static void InnerMethodBody(IndentedStringBuilder srcBuilder, SimpleSyntax.Method member)
    {
        srcBuilder
            .AppendLine(CallHistoryGenerator.GenerateAddCall(MethodKind.Ordinary, member))
            .AppendLine(ThrowIfNull(MethodKind.Ordinary, member))
            .AppendLine(InvokeFuncPointer(MethodKind.Ordinary, member));
    }
}
