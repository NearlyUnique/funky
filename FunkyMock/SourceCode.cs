using FunkyMock.External;
using Microsoft.CodeAnalysis;

namespace FunkyMock;

/// <summary>
/// Methods to write C# source code
/// </summary>
public static class SourceCode
{
    /// <summary>
    /// I'm not happy about adding this. But currently I cannot work out how to fully qualify all types found on the interface
    /// </summary>
    public const string GlobalUsing = """
// Standard global using
using global::System;
using global::System.Collections.Generic;
using global::System.IO;
using global::System.Linq;
using global::System.Net.Http;
using global::System.Threading;
using global::System.Threading.Tasks;
""";

    /// <summary>
    /// public {returnType} {name}(arg list)
    /// </summary>
    /// <returns></returns>
    public static string Signature(SimpleSyntax.Method m)
    {
        if (m.Kind == MethodKind.Ordinary)
        {
            return $"public {m.ReturnType} {m.Name}({string.Join(", ", m.Args)})";
        }
        return $"public {m.ReturnType} {m.Name}";
    }

    /// <summary>
    /// public [Func|Action] &lt;{type list}&gt;;
    /// </summary>
    /// <returns></returns>
    public static string FuncPointer(MethodKind kind, SimpleSyntax.Method m)
    {
        var funcType = "Action";
        var args = new List<string>();

        args.AddRange(m.Args.Select(x => x.Type));
        if (m.ReturnType != "void")
        {
            funcType = "Func";
            args.Add(m.ReturnType);
        }
        string typeParams = "";
        if (args.Any())
        {
            typeParams = "<"+string.Join(", ", args)+">";
        }
        var name = (kind & m.Kind) switch {
            MethodKind.Ordinary => m.Name,
            MethodKind.ReadProperty => "Get"+m.Name,
            MethodKind.WriteProperty => "Set"+m.Name,
            _ => throw new InvalidOperationException("Ordinary, ReadProperty or Write Property only")
        };

        return $"public {funcType}{typeParams}? On{name};";
    }

    /// <summary>
    /// (return) On{name}(args);
    /// </summary>
    /// <returns></returns>
    public static string InvokeFuncPointer(SimpleSyntax.Method m)
    {
        var @return = "return ";
        if (m.Kind == MethodKind.Ordinary)
        {
            if (m.ReturnType == "void")
            {
                @return = "";
            }

            return $"{@return}On{m.Name}({string.Join(", ", m.Args.Select(x => x.Name))});";
        }

        if ((m.Kind & MethodKind.ReadProperty) != 0)
        {
            return $"return OnGet{m.Name}();";
        }

        return "!";
    }

    /// <summary>
    /// if ( On{MethodName} is null ) throw Exception();
    /// </summary>
    /// <param name="kind">required kind</param>
    /// <param name="m"></param>
    /// <returns></returns>
    public static string ThrowIfNull(MethodKind kind, SimpleSyntax.Method m)
    {
        kind &= m.Kind;
        var name = kind switch {
            MethodKind.Ordinary => m.Name,
            MethodKind.ReadProperty => "Get"+m.Name,
            MethodKind.WriteProperty => "Set"+m.Name,
            _ => throw new InvalidOperationException("Ordinary, ReadProperty or Write Property only")
        };

        return
            $"if (On{name} is null) {{ throw new System.NotImplementedException(\"'On{name}' has not been assigned\"); }}";
    }

    public static string Execute(FunkyContext source)
    {
        var targetInterface = source.TargetInterface;

        var srcBuilder = new IndentedStringBuilder();

        srcBuilder
            .AppendLine("// <auto-generated/>")
            .AppendLine("#nullable enable")
            .AppendLine($"namespace {SimpleSyntax.Namespace(source.MockClass)};")
            .AppendLine()
            .AppendLine(GlobalUsing)
            .AppendLine()
            .AppendLine($"{SimpleSyntax.Accessibility(source.MockClass)} partial class {source.MockClassName} : {SimpleSyntax.Namespace(source.TargetInterface)}.{source.TargetInterfaceName}")
            .AppendLine("{")
            .IncrementIndent();

        AddFunctionPointers(srcBuilder, targetInterface);
        ImplementInterface(srcBuilder, targetInterface);

        srcBuilder
            .DecrementIndent()
            .AppendLine("}");

        return srcBuilder.ToString();
    }

    private static void ImplementInterface(IndentedStringBuilder srcBuilder, INamedTypeSymbol targetInterface)
    {
        foreach (var member in SimpleSyntax.Members(targetInterface))
        {
            srcBuilder.Append(Signature(member))
                .AppendLine(" {")
                .IncrementIndent();

            if (member.Kind == MethodKind.Ordinary)
            {
                InnerMethodBody(srcBuilder, member);
            }
            else
            {
                InnerPropertyBody(srcBuilder, member);
            }

            srcBuilder
                .DecrementIndent()
                .AppendLine("}");
        }
    }

    private static void AddFunctionPointers(IndentedStringBuilder srcBuilder, INamedTypeSymbol targetInterface)
    {
        void AppendIf(MethodKind kind, SimpleSyntax.Method member)
        {
            if (member.Kind == kind)
            {
                srcBuilder.AppendLine(FuncPointer(kind, member));
            }
        }

        foreach (var member in SimpleSyntax.Members(targetInterface))
        {
            AppendIf(MethodKind.Ordinary, member);
            AppendIf(MethodKind.ReadProperty, member);
            AppendIf(MethodKind.WriteProperty, member);
        }

        srcBuilder.AppendLine();
    }

    private static void InnerPropertyBody(IndentedStringBuilder srcBuilder, SimpleSyntax.Method member)
    {
        srcBuilder
            .AppendLine("get {")
            .IncrementIndent()
            .AppendLine(ThrowIfNull(MethodKind.ReadProperty, member))
            .AppendLine(InvokeFuncPointer(member))
            .DecrementIndent()
            .AppendLine("}");
    }

    private static void InnerMethodBody(IndentedStringBuilder srcBuilder, SimpleSyntax.Method member)
    {
        srcBuilder
            .AppendLine(ThrowIfNull(MethodKind.Ordinary, member))
            .AppendLine(InvokeFuncPointer(member));
    }
}
