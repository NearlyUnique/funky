namespace FunkyGen;

public sealed partial class FunkyGenerator
{
    private static readonly string FunkyNamespaceName = "FunkyGen";
    private static readonly string FunkyNamespaceShortName = "Funky";
    private static readonly string FunkyNamespaceLongName = $"{FunkyNamespaceShortName}Attribute";
    private static readonly string FunkyAttributeFullname = $"{FunkyNamespaceName}.{FunkyNamespaceLongName}";

    private static readonly string GeneratedCodeAttribute =
        $@"[global::System.CodeDom.Compiler.GeneratedCodeAttribute("+
        $@"""{typeof(FunkyGenerator).Assembly.GetName().Name}"", "+
        $@"""{typeof(FunkyGenerator).Assembly.GetName().Version}"""+
        $@")]";

    private static readonly string FunkyMockAttributeSource = $@"// <auto-generated/>
#nullable enable
namespace {FunkyNamespaceName};
{GeneratedCodeAttribute}
[global::System.AttributeUsageAttribute(global::System.AttributeTargets.Class, AllowMultiple = false, Inherited = false)]
internal sealed class {FunkyNamespaceLongName} : global::System.Attribute
{{
    public {FunkyNamespaceLongName}(global::System.Type type) => Type = type;
    public global::System.Type Type {{ get; }}
}}
";

    /// <summary>
    /// I'm not happy about adding this. But currently I cannot work out how to fully qualify all types found on the interface
    /// </summary>
    private const string GlobalUsing = """
// Standard global using
using global::System;
using global::System.Collections.Generic;
using global::System.IO;
using global::System.Linq;
using global::System.Net.Http;
using global::System.Threading;
using global::System.Threading.Tasks;
""";
}
